---
title: "workflow_micro_NYC"
author: "Jiali Zhu"
date: "today"
format:
  html:
    code-overflow: wrap
    code-fold: true
    code-summary: "Code"
editor: visual
---

```{r}
#| label: load-packages
#| include: false
#| warning: false

library(zhulabtools)
load_packages(c("dplyr","lubridate", "ggplot2", "sf","sp", "readr", "purrr", "stringr","glue", "tidyr", "broom","lme4", "knitr", "broom.mixed", "ppcor", "spdep", "spatialreg", "lmtest","car", "spBayes", "coda", "patchwork", "performance"))
# source("~/phenology-urban/script/read_clean_WU.R")
select <- dplyr::select
```

## 1. Raw data

### 1.1 Insert tree id base on WU data

For exploratory analysis, I used the street tree in NYC, with the phenology information established by Yiluan. These trees are part of the whole inventory, covering only 14 genera and being sampled. I select the trees which are within 500-m buffer around the weather underground sites (see @fig-tree_wu_sites).

```{r}
#| label: tree_wu_sites
#| include: false
#| warning: false

################ For phenology data ################

metadata <- read_csv("~/lab-data/datasets/vegetation/PS/urban/metadata.csv") %>%
  filter(site == "NY")

file_list <- list.files(path = "~/lab-data/datasets/vegetation/PS/urban/doy/", pattern = "^doy_NY_.*\\.rds$", full.names = TRUE)
data_list <- file_list %>%
  map(~ readRDS(.x))
ny_now <- bind_rows(data_list)

tree_location <- metadata %>%
  mutate(genus = str_extract(taxa, "^[^ ]+")) %>%
  left_join(ny_now, by = "id") %>%
  filter(!is.na(doy))

just_tree_location <- tree_location %>%
  group_by(id) %>%
  slice(1) %>%
  ungroup() %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)

wu_location <- read_csv("~/urban-cooling/data/raw/WU/NY/location.csv", show_col_types = FALSE) %>%
  st_as_sf(coords = c("Lon", "Lat"), crs = 4326)
wu_buffer <- st_buffer(wu_location, dist = 500)

intersects <- st_intersects(just_tree_location, wu_buffer)

id_buffer <- just_tree_location %>%
  mutate(buffer_id = sapply(intersects, function(x) if (length(x) == 1) x[1] else NA)) %>% 
  left_join(wu_buffer %>% st_drop_geometry() %>% mutate(buffer_id = row_number()), by = "buffer_id") %>%
  filter(!is.na(buffer_id)) %>%
  dplyr::select(id, Site) %>%
  rbind(
    just_tree_location %>%
    filter(lengths(intersects) > 1) %>%
    rowwise() %>%
    mutate(
      Site = {
        current_row_index <- which(just_tree_location$id == id)
        intersected_buffers <- intersects[[current_row_index]]
        point_geom <- geometry
        buffer_geoms <- wu_location[intersected_buffers, ]$geometry
        distances <- st_distance(point_geom, buffer_geoms)
        nearest_index <- which.min(distances)
        wu_buffer$Site[intersected_buffers[nearest_index]]
      }
    ) %>%
    ungroup() %>%
    dplyr::select(id, Site)
  )

points_in_buffer <- tree_location %>%
  left_join(id_buffer, by = "id") %>%
  filter(!is.na(Site))

# write_csv(points_in_buffer, "~/phenology-urban/data/proc/urban/NY/tree_WU_500_buffer_PS.csv")
points_in_buffer <- read_csv("~/phenology-urban/data/proc/urban/NY/tree_WU_500_buffer_PS.csv", show_col_types = FALSE)

```

```{r}
#| label: fig-tree_wu_sites
#| include: true
#| fig-cap: "Location of WU sites and trees"
#| warning: false

points_in_buffer_sf <- points_in_buffer %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)
boundary <- st_read("~/urban-cooling/data/raw/NYC/boundary/nybb_dissolved.shp") %>%
  st_transform(4326)

ggplot() +
  geom_sf(data = boundary, fill = "grey") +
  geom_sf(data = wu_location, color = "blue", size = 1) +
  geom_sf(data = points_in_buffer_sf, color = "red", size = 0.05) +
  theme_minimal()

```

### 1.2 Read and clean the WU data (based on GHCNd)

There are 4 raw daily variables selected, i.e. AvgTemp, HighTemp, LowTemp and Precipitation_sum (Sum_mm). I flagged the records which are unknown or questionable according to the methods applied by Global Historical Climatology Network daily [GHCNd](https://www.ncei.noaa.gov/products/land-based-station/global-historical-climatology-network-daily).

```{r}
#| label: read_wu_data
#| include: true
#| warning: false

# all_sites_temp <- read_clean_WU(city = "NY", run_checks = TRUE)
all_sites_temp <- readRDS("~/urban-cooling/data/raw/WU/NY/NY_wu.rds") %>%
  dplyr::select(c(Date, HighTemp, AvgTemp, LowTemp, Sum_mm, name))
```

### 1.3 Shortwave data from Daymet

```{r}
#| label: plot_function
#| include: true
#| warning: false
srad_daily <- readRDS("~/phenology-urban/data/raw/NY/Daymet/daily2016-2024/srad_daily_2016-2023.rds")
```

## 2 Find the optimal preseason

The seasonal climate variables use a fixed pre-season for every trees, not allowing heterogeneity within city. Also, the roughly divided season make it difficult to connect to phenology process, e.g. chilling and forcing accumulation. Therefore, some studies use varing preseason or optimal preseason.

[Meng et al., 2020](https://www.sciencedirect.com/science/article/pii/S0168192319304484?via%3Dihub), [Wang et al., 2021](https://onlinelibrary.wiley.com/doi/10.1111/gcb.15777): The preseason was defined as the period from November 1st in the previous year to the time of `SOS` in the current year. (most fixed)

[Meng et al., 2020](https://www.pnas.org/doi/10.1073/pnas.1911117117#sec-3), [Yin et al., 2024](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2023EF004127): For each city, the period for which the absolute value of the partial correlation coefficient between `SOS` and `Temp` was highest was considered the optimal length of the preseason most relevant to `SOS`. (more flexible, cadidate time: 0 to 6 months prior to SOS, 5-day interval approach from January 1st to the average SOS date)

Here, based on the variable (phenology metric: `SOS`, `EOS`, `green-up pace`, `green-down pace`, temp. metric: t_avg, t_min, t_max), I find the optimal preseason at genus-city level (ignore the year for now due to sample size). The period for which the absolute value of the partial correlation coefficient between phenology and temp. metric is highest is considered the optimal length of the preseason most relevant to the certain phenology metric.

```{r}
#| label: optimal_preseason_fun
#| include: true
#| warning: false

calculate_partial_correlation <- function(insert_data, direction, thres, genus, priors, 
                                          phe_variable, temp_variable) {
  subset_tree_pcor <- insert_data %>%
    filter(direction == !!direction & thres == !!thres & genus == !!genus)
  results <- lapply(priors, function(prior) {
    cat("Prior:", prior, "\n")
    preseason_var <- subset_tree_pcor %>%
      mutate(
        start_date = make_date(year) + days(round(mean(doy)) - 1) - days(prior),
        end_date = make_date(year) + days(round(mean(doy)) - 1)
      )

    temp_stats <- all_sites_temp %>%
      filter(name %in% preseason_var$Site) %>%
      inner_join(preseason_var, by = c("name" = "Site")) %>%
      filter(Date >= start_date & Date <= end_date) %>%
      group_by(id,year) %>%
      summarise(
        LowTemp_mean = mean(LowTemp, na.rm = TRUE),
        LowTemp_count = sum(!is.na(LowTemp)),
        AvgTemp_mean = mean(AvgTemp, na.rm = TRUE),
        AvgTemp_count = sum(!is.na(AvgTemp)),
        HighTemp_mean = mean(HighTemp, na.rm = TRUE),
        HighTemp_count = sum(!is.na(HighTemp)),
        Sum_mm_sum = sum(Sum_mm, na.rm = TRUE),
        Sum_mm_count = sum(!is.na(Sum_mm)),
        .groups = "drop"
      )
  
    srad_stats <- srad_daily %>%
      filter(id %in% preseason_var$id) %>%
      inner_join(preseason_var, by = "id") %>%
      filter(date >= start_date & date <= end_date) %>%
      group_by(id,year) %>%
      summarise(
        srad_mean = mean(value, na.rm = TRUE),
        srad_count = sum(!is.na(value)),
        .groups = "drop"
      )
    
    preseason_var <- preseason_var %>%
      left_join(temp_stats, by = c("id","year")) %>%
      left_join(srad_stats, by = c("id","year"))
    
    
    if (temp_variable %in% c("LowTemp_mean", "HighTemp_mean")){
      selected_data <- preseason_var %>%
      dplyr::select(
        {{ phe_variable }}, LowTemp_mean, HighTemp_mean, Sum_mm_sum,  srad_mean
      ) %>%
      na.omit()
    } else {
      selected_data <- preseason_var %>%
      dplyr::select(
        {{ phe_variable }}, AvgTemp_mean,Sum_mm_sum, srad_mean
      ) %>%
      na.omit()
    }
    partial_corr <- pcor(selected_data)
    
    correlation <- partial_corr$estimate[
        rownames(partial_corr$estimate) == phe_variable, 
        colnames(partial_corr$estimate) == temp_variable
      ]
    pvalue <- partial_corr$p.value[
        rownames(partial_corr$p.value) == phe_variable, 
        colnames(partial_corr$p.value) == temp_variable
      ]
  list(correlation = correlation, pvalue = pvalue, preseason_var = preseason_var)
  })
  
  correlations <- sapply(results, function(x) (x$correlation))
  pvalues <- sapply(results, function(x) (x$pvalue))
  
  
  max_idx <- which.max(abs(correlations))
  
  return(list(
    optimal_prior = priors[max_idx],
    prior_candidate  = priors,
    prior_trend = correlations,
    pvalue_trend = pvalues,
    partial_correlation = results[[max_idx]]$correlation,
    partial_corr_pvalue = results[[max_idx]]$pvalue,
    preseason_var = results[[max_idx]]$preseason_var
  ))
}


priors <- seq(5, 180, by = 5)
all_genus <- unique(points_in_buffer$genus)
temp_variable = "AvgTemp_mean"
```

### 2.1 Spring phenology

#### `SOS` date

Defined as the day of year when individual tree growing season EVI curves first cross the green-up 50% threshold.

```{r}
#| label: optimal_preseason_SOS
#| eval: FALSE
#| include: true
#| warning: false


direction <- "up"
thres <- 0.5
phe_variable = "doy"
insert_data = points_in_buffer

all_results <- list()
all_results <- lapply(all_genus, function(genus) {
  cat("Processing genus:", genus, "\n")
  result <- calculate_partial_correlation(
    insert_data = insert_data,
    direction = direction,
    thres = thres,
    genus = genus,
    priors = priors,
    phe_variable = phe_variable,
    temp_variable = temp_variable
  )
  return(result)
})

spring_date_preseason_var <- do.call(rbind, lapply(all_results, function(x) x$preseason_var))
spring_date_combined_results <- lapply(all_results, function(x) {
  list(
    genus = unique(x$preseason_var$genus),
    optimal_prior = x$optimal_prior,
    partial_correlation = x$partial_correlation,
    partial_corr_pvalue = x$partial_corr_pvalue,
    prior_candidate = x$prior_candidate,
    prior_trend = x$prior_trend,
    pvalue_trend = x$pvalue_trend
  )
})
spring_date_combined_results <- do.call(rbind, lapply(spring_date_combined_results, as.data.frame))

```

#### Green-up Pace

Defined as the time span (in days) required for the individual tree growing season EVI curves to transition from the green-up 20% threshold to the 80% threshold.

```{r}
#| label: optimal_preseason_greenup_pace
#| eval: FALSE
#| include: true

diff <- points_in_buffer %>%
  group_by(year, id, direction) %>%
  filter(thres %in% c(0.2, 0.8)) %>% 
  summarise(
    doy_diff = abs(diff(doy[order(thres)])),
    .groups = "drop"
  )

points_with_diff <- points_in_buffer %>%
  left_join(diff, by = c("year", "id", "direction"))

direction <- "up"
thres <- 0.2              # change to 0.5?
phe_variable = "doy_diff"
temp_variable = "HighTemp_mean"
insert_data = points_with_diff

all_results <- list()
all_results <- lapply(all_genus, function(genus) {
  cat("Processing genus:", genus, "\n")
  result <- calculate_partial_correlation(
    insert_data = insert_data,
    direction = direction,
    thres = thres,
    genus = genus,
    priors = priors,
    phe_variable = phe_variable,
    temp_variable = temp_variable
  )
  return(result)
})

spring_pace_preseason_var <- do.call(rbind, lapply(all_results, function(x) x$preseason_var))
spring_pace_combined_results <- lapply(all_results, function(x) {
  list(
    genus = unique(x$preseason_var$genus),
    optimal_prior = x$optimal_prior,
    partial_correlation = x$partial_correlation,
    partial_corr_pvalue = x$partial_corr_pvalue,
    prior_candidate = x$prior_candidate,
    prior_trend = x$prior_trend,
    pvalue_trend = x$pvalue_trend
  )
})
spring_pace_combined_results <- do.call(rbind, lapply(spring_pace_combined_results, as.data.frame))

```

### 2.2 Fall phenology

#### `EOS` date

Defined as the day of year when individual tree growing season EVI curves first cross the green-down 50% threshold.

```{r}
#| label: optimal_preseason_EOS
#| layout-ncol: 2
#| eval: FALSE
#| include: true
#| warning: false

direction <- "down"
thres <- 0.5
phe_variable = "doy"
temp_variable = "HighTemp_mean"
insert_data = points_in_buffer

all_results <- list()
all_results <- lapply(all_genus, function(genus) {
  cat("Processing genus:", genus, "\n")
 
  result <- calculate_partial_correlation(
    insert_data = insert_data,
    direction = direction,
    thres = thres,
    genus = genus,
    priors = priors,
    phe_variable = phe_variable,
    temp_variable = temp_variable
  )
  return(result)
})

fall_date_preseason_var <- do.call(rbind, lapply(all_results, function(x) x$preseason_var))
fall_date_combined_results <- lapply(all_results, function(x) {
  list(
    genus = unique(x$preseason_var$genus),
    optimal_prior = x$optimal_prior,
    partial_correlation = x$partial_correlation,
    partial_corr_pvalue = x$partial_corr_pvalue,
    prior_candidate = x$prior_candidate,
    prior_trend = x$prior_trend,
    pvalue_trend = x$pvalue_trend
  )
})
fall_date_combined_results <- do.call(rbind, lapply(fall_date_combined_results, as.data.frame))
```

#### Green-down Pace

Defined as the time span (in days) required for the individual tree growing season EVI curves to transition from the green-down 20% threshold to the 80% threshold.

```{r}
#| label: optimal_preseason_greendown_pace
#| eval: FALSE
#| include: TRUE
direction <- "down"
thres <- 0.2              # change to 0.5?
phe_variable = "doy_diff"
temp_variable = "HighTemp_mean"
insert_data = points_with_diff

all_results <- list()
all_results <- lapply(all_genus, function(genus) {
  cat("Processing genus:", genus, "\n")
 
  result <- calculate_partial_correlation(
    insert_data = insert_data,
    direction = direction,
    thres = thres,
    genus = genus,
    priors = priors,
    phe_variable = phe_variable,
    temp_variable = temp_variable
  )
  return(result)
})

fall_pace_preseason_var <- do.call(rbind, lapply(all_results, function(x) x$preseason_var))
fall_pace_combined_results <- lapply(all_results, function(x) {
  list(
    genus = unique(x$preseason_var$genus),
    optimal_prior = x$optimal_prior,
    partial_correlation = x$partial_correlation,
    partial_corr_pvalue = x$partial_corr_pvalue,
    prior_candidate = x$prior_candidate,
    prior_trend = x$prior_trend,
    pvalue_trend = x$pvalue_trend
  )
})
fall_pace_combined_results <- do.call(rbind, lapply(fall_pace_combined_results, as.data.frame))
```

```{r}
#| label: store_resuts
#| eval: FALSE
#| include: false
# tavg_allyear_var <- spring_date_preseason_var %>%
#   mutate(doy_diff = "NA") %>%
#   rbind(spring_pace_preseason_var, fall_pace_preseason_var) %>%
#   rbind(fall_date_preseason_var %>% mutate(doy_diff = "NA")) %>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_var.rds")

# tavg_allyear_pcorr <- spring_date_combined_results %>%
#   mutate(type = "SOS") %>%
#   rbind(spring_pace_combined_results %>% mutate(type = "green-up pace")) %>%
#   rbind(fall_pace_combined_results %>% mutate(type = "green-down pace")) %>%
#   rbind(fall_date_combined_results %>% mutate(type = "EOS"))%>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_pcorr.rds")

# thigh_allyear_var <- spring_date_preseason_var %>%
#   mutate(doy_diff = "NA") %>%
#   rbind(spring_pace_preseason_var, fall_pace_preseason_var) %>%
#   rbind(fall_date_preseason_var %>% mutate(doy_diff = "NA")) %>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/thigh_allyear_var.rds")
# 
# thigh_allyear_pcorr <- spring_date_combined_results %>%
#   mutate(type = "SOS") %>%
#   rbind(spring_pace_combined_results %>% mutate(type = "green-up pace")) %>%
#   rbind(fall_pace_combined_results %>% mutate(type = "green-down pace")) %>%
#   rbind(fall_date_combined_results %>% mutate(type = "EOS"))%>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/thigh_allyear_pcorr.rds")
# 
# tlow_allyear_var <- spring_date_preseason_var %>%
#   mutate(doy_diff = "NA") %>%
#   rbind(spring_pace_preseason_var, fall_pace_preseason_var) %>%
#   rbind(fall_date_preseason_var %>% mutate(doy_diff = "NA")) %>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/tlow_allyear_var.rds")
# 
# tlow_allyear_pcorr <- spring_date_combined_results %>%
#   mutate(type = "SOS") %>%
#   rbind(spring_pace_combined_results %>% mutate(type = "green-up pace")) %>%
#   rbind(fall_pace_combined_results %>% mutate(type = "green-down pace")) %>%
#   rbind(fall_date_combined_results %>% mutate(type = "EOS"))%>%
#   saveRDS("~/phenology-urban/data/proc/urban/NY/tlow_allyear_pcorr.rds")
```

### 2.3 Optimal preseason length calculated by Temp~avg~

@fig-partial_preseason displays the distribution of optimal preseason length and partial correlation coefficient calculated by Temp~avg~ for `SOS`, `Greenup pace`, `EOS` and `Greenup pace`, respectively.

As for `SOS`, all genera have negetive partial correlation coefficients, which means the higher preseason average temperature, the earlier start of season. As for `Greenup pace`, most genera (except Carya, Celtis) have negetive partial correlation coefficients, which means the higher preseason average temperature, the faster green up pace. The preseason length varies significantly among genera.

As for `EOS`, most genera (except Populus, Platanus) have positive partial correlation coefficients, which means the higher preseason average temperature, the later end of season. As for `Greenup pace`, there is variation in impact direction among genera. The preseason length also varies significantly among genera.

```{r}
#| label: fig-partial_preseason
#| layout-ncol: 1
#| fig-cap: "Distribution of partial correlation coefficient and preseason length, calculated by Temp~avg~"
#| fig-subcap: 
#|   - "Spring phenology"
#|   - "Fall phenology"
#| warning: false

tavg_allyear_pcorr <- readRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_pcorr.rds") %>%
  select(genus, optimal_prior, partial_correlation, partial_corr_pvalue, type) %>%
  group_by(genus, optimal_prior, partial_correlation, partial_corr_pvalue, type) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_wider(
    names_from = type,
    values_from = c(optimal_prior, partial_correlation, partial_corr_pvalue)
  ) %>%
  mutate(
    group_spring = case_when(
      partial_corr_pvalue_SOS <= 0.05 & `partial_corr_pvalue_green-up pace` <= 0.05 ~ "1",
      partial_corr_pvalue_SOS <= 0.05 & `partial_corr_pvalue_green-up pace` > 0.05 ~ "2",
      partial_corr_pvalue_SOS > 0.05 & `partial_corr_pvalue_green-up pace` <= 0.05 ~ "3",
      TRUE ~ "4"
    ),
    group_fall = case_when(
      partial_corr_pvalue_EOS <= 0.05 & `partial_corr_pvalue_green-down pace` <= 0.05 ~ "1",
      partial_corr_pvalue_EOS <= 0.05 & `partial_corr_pvalue_green-down pace` > 0.05 ~ "2",
      partial_corr_pvalue_EOS > 0.05 & `partial_corr_pvalue_green-down pace` <= 0.05 ~ "3",
      TRUE ~ "4"
    )
  )

spring_pcorr_p <- ggplot(tavg_allyear_pcorr, aes(x = partial_correlation_SOS, y = `partial_correlation_green-up pace`, color = group_spring, label = genus)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.6, hjust = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_color_manual(
    values = c("1" = "mediumorchid4", "2" = "lightpink", "3" = "lightblue1", "4" = "gray95"),
    labels = c(
      "1" = "Both p-values < 0.05",
      "2" = "SOS p-value < 0.05 \n Green-up p-value > 0.05",
      "3" = "SOS p-value > 0.05 \n Green-up p-value < 0.05",
      "4" = "Both p-values > 0.05"
    )
  ) +
  labs(
    x = "Partial correlation coefficient (SOS)",
    y = "Partial correlation coefficient (Green-up pace)",
    color = "Group",
    title = "Distribution of\npartial correlation coefficient"
  ) +
  theme_minimal()  +
  theme(legend.position = "bottom")

spring_prior_p <- ggplot(tavg_allyear_pcorr, aes(x = optimal_prior_SOS, y = `optimal_prior_green-up pace`, color = group_spring, label = genus)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.6, hjust = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_color_manual(
    values = c("1" = "mediumorchid4", "2" = "lightpink", "3" = "lightblue1", "4" = "gray95"),
    labels = c(
      "1" = "Both p-values < 0.05",
      "2" = "SOS p-value < 0.05 \n Green-up p-value > 0.05",
      "3" = "SOS p-value > 0.05 \n Green-up p-value < 0.05",
      "4" = "Both p-values > 0.05"
    )
  ) +
  labs(
    x = "Optimal preseason length (SOS)",
    y = "Optimal preseason length (Green-up Pace)",
    color = "Group",
    title = "Distribution of preseason length"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

fall_pcorr_p <- ggplot(tavg_allyear_pcorr, aes(x = partial_correlation_EOS, y = `partial_correlation_green-down pace`, color = group_fall, label = genus)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.6, hjust = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_color_manual(
    values = c("1" = "mediumorchid4", "2" = "lightpink", "3" = "lightblue1", "4" = "gray95"),
    labels = c(
      "1" = "Both p-values < 0.05",
      "2" = "EOS p-value < 0.05 \n Green-down p-value > 0.05",
      "3" = "EOS p-value > 0.05 \n Green-down p-value < 0.05",
      "4" = "Both p-values > 0.05"
    )
  ) +
  labs(
    x = "Partial correlation coefficient (EOS)",
    y = "Partial correlation coefficient (Green-down pace)",
    color = "Group",
    title = "Distribution of\npartial correlation coefficient"
  ) +
  theme_minimal()  +
  theme(legend.position = "bottom")

fall_prior_p <- ggplot(tavg_allyear_pcorr, aes(x = optimal_prior_EOS, y = `optimal_prior_green-down pace`, color = group_fall, label = genus)) +
  geom_point(size = 3) +
  geom_text(vjust = -0.6, hjust = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_color_manual(
    values = c("1" = "mediumorchid4", "2" = "lightpink", "3" = "lightblue1", "4" = "gray95"),
    labels = c(
      "1" = "Both p-values < 0.05",
      "2" = "EOS p-value < 0.05 \n Green-down p-value > 0.05",
      "3" = "EOS p-value > 0.05 \n Green-down p-value < 0.05",
      "4" = "Both p-values > 0.05"
    )
  ) +
  labs(
    x = "Optimal preseason length (EOS)",
    y = "Optimal preseason length (Green-down Pace)",
    color = "Group",
    title = "Distribution of preseason length"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

spring_pcorr_p + spring_prior_p + plot_layout(guides = "collect") & theme(legend.position = "bottom")
fall_pcorr_p + fall_prior_p + plot_layout(guides = "collect") & theme(legend.position = "bottom")
```

## 3 Spatial pattern (SOS \~ T~avg~)

### 3.1 Check spatial autocorrelation

Both fixed-effect model and mixed-effects model have heterogeneous residuals. `Global Moran I for regression residuals` test indicates the presence of spatial autocorrelation in the residuals. `Lagrange Multiplier` test suggests the spatial model should be applied.

```{r}
#| label: check_sp_auto
#| include: true

tavg_allyear_var <- readRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_var.rds")
tavg_SOS <- tavg_allyear_var %>% filter(direction == "up" & thres == 0.5) %>%
  na.omit()

regOLS <- lm(doy~ AvgTemp_mean + Sum_mm_sum + srad_mean + genus, data = tavg_SOS)
mixed_OLS <- lmer(doy~ AvgTemp_mean + Sum_mm_sum + srad_mean +
                    (1|genus), data = tavg_SOS)
print(check_heteroscedasticity(mixed_OLS))


coordinates(tavg_SOS) <- ~ lon + lat
knea <- dnearneigh(coordinates(tavg_SOS), 0.0001, 1, longlat = TRUE)
nqR <- nb2listw(knea, style = "W")

lm.morantest(regOLS, nqR, alternative="two.sided")
summary(lm.RStests(regOLS,nqR,test="all"))
```

### 3.2 Spatial statistical model using *spBayes*

We modeled the relationship between the day of year ($\text{DOY}$) and environmental covariates using a spatial hierarchical model. The response variable at location $\mathbf{s}_i$, denoted as $y(\mathbf{s}_i)$, was modeled as follows:

$$ y(\mathbf{s}_i) = \mu(\mathbf{s}_i) + w(\mathbf{s}_i) + \epsilon(\mathbf{s}_i) $$

where:

-   $\mu(\mathbf{s}_i) = \mathbf{X}_i \boldsymbol{\beta}$ represents the fixed effects, with $\mathbf{X}_i = [1, \text{AvgTemp}, \text{Precp}, \text{srad}]$ being the design matrix of predictors, and $\boldsymbol{\beta} = [\beta_0, \beta_1, \beta_2, \beta_3]$ representing the regression coefficients.

-   $w(\mathbf{s}_i) \sim \text{MVN}(0, \mathbf{R}\sigma^2)$ represents the spatially correlated random effect, with $\mathbf{R}$ being the spatial correlation matrix constructed using an exponential covariance function: $$\mathbf{R}_{ij} = \text{exp}(-\phi \cdot D_{ij})$$ where $D_{ij}$ is the Euclidean distance between locations $\mathbf{s}_i$ and $\mathbf{s}_j$, and $\phi$ controls the range of spatial correlation.

-   $\epsilon(\mathbf{s}_i) \sim \text{N}(0, \tau^2)$ represents the independent nugget effect, capturing measurement error or small-scale variability.

-   Prior distributions:

    -   $\boldsymbol{\beta} \sim \text{MVN}(\mathbf{0}, 1000\mathbf{I})$
    -   $\phi \sim \text{Uniform}(5, 50)$
    -   $\sigma^2 \sim \text{Inverse-Gamma}(3, 80)$
    -   $\tau^2 \sim \text{Inverse-Gamma}(3, 200)$

Problem with `year` (replicate location):

-   [x] **Add some jitter to duplicated coordinates**
-   [ ] Treat `year` as random/fixed effect
-   [ ] Use function `spDynLM`

Problem with `genus`:

-   [x] **Not include**
-   [x] **Fit each genus separately**
-   [ ] Treat `genus` as random effect

#### 3.2.1 Not include `genus`

The first relationship I test is $\text{DOY} \sim \text{Temp}_{\text{avg}}$. The distribution of $\beta_{\text{Temp}_{\text{avg}}}$ is concentrated at -1.65, which means the warmer the preseason temperature, the earlier the spring phenology, considering the spatial autocorrelation of phenology in the model (@fig-ny_allgenus_tavg_SOS_2).

```{r}
#| label: ny_allgenus_tavg_SOS
#| include: true
#| fig-height: 10
#| fig-cap: 
#|   - "Trace plot of correlation coefficients"
#|   - "Trace plot of hyperparameters"
#| warning: false

set.seed(2025)
coords <- coordinates(tavg_SOS)
duplicated_flags <- duplicated(coords) | duplicated(coords, fromLast = TRUE)
jitter_matrix <- matrix(0, nrow = nrow(coords), ncol = 2)
jitter_matrix[duplicated_flags, ] <- matrix(rnorm(sum(duplicated_flags) * 2, mean = 0, sd = 1e-6),  ncol = 2)
coords_jittered <- coords + jitter_matrix

tavg_SOS_df <- as.data.frame(tavg_SOS)
tavg_SOS_df$lon <- coords_jittered[, 1]
tavg_SOS_df$lat <- coords_jittered[, 2]

num_predictors <- 4
D <- as.matrix(dist(coords_jittered))
n.samples <- 3000
starting <- list("phi" = 25, "sigma.sq" = 40, "tau.sq" = 100)
tuning <- list("phi" = 0.1, "sigma.sq" = 0.1, "tau.sq" = 0.1)
priors <- list(
  "beta.Norm" = list(mean = rep(0, num_predictors), var = diag(1000, num_predictors)),
  "phi.Unif" = c(5 / 1, 5 / 0.1),
  "sigma.sq.IG" = c(3, 80),
  "tau.sq.IG" = c(3, 200)
)


formula <- as.formula("doy ~ AvgTemp_mean + Sum_mm_sum + srad_mean")

# model <- spLM(formula, data=tavg_SOS_df, coords=coords_jittered,
#               starting=starting, tuning=tuning, priors=priors, knots = c(20, 20, 0),
#               cov.model="exponential", verbose=TRUE, n.samples=n.samples, n.report=25)
# save(model, file = "result/urban/ny_all_genus_tavg_SOS.RData")
load("~/phenology-urban/data/proc/urban/ny_all_genus_tavg_SOS.RData")

plot(model$p.beta.samples)
plot(model$p.theta.samples)
```

```{r}
#| label: fig-ny_allgenus_tavg_SOS_2
#| include: true
#| fig-cap: 
#|   - "Distribution of (SOS ~ AvgTemp) coefficent"
#| warning: false



burn.in <- 0.5* n.samples
##recover beta and spatial random effects
# m.1 <- spRecover(model, start=burn.in, verbose=FALSE)
# save(m.1, file = "result/urban/ny_all_genus_tavg_SOS_re.RData")
load("~/phenology-urban/data/proc/urban/ny_all_genus_tavg_SOS_re.RData")

beta_samples <- as.matrix(m.1$p.beta.recover.samples)
temp_coefficients <- beta_samples[, "AvgTemp_mean"]
mean_ndvi_coef <- mean(temp_coefficients)
lower_ci <- quantile(temp_coefficients, 0.025)
upper_ci <- quantile(temp_coefficients, 0.975)

ndvi_coef_df <- data.frame(
  Coefficient = temp_coefficients,
  Type = "Avg_temp"
)
ggplot(ndvi_coef_df, aes(x = Coefficient)) +
  geom_histogram(binwidth = 0.01, fill = "blue", alpha = 0.7) +
  geom_vline(xintercept = mean_ndvi_coef, color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = mean_ndvi_coef, y = 75, label = paste0("Mean: ", round(mean_ndvi_coef, 2)), 
           color = "red", vjust = -1.5, hjust = 0.5) +
  geom_vline(xintercept = lower_ci, color = "green", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = upper_ci, color = "green", linetype = "dashed", linewidth = 1) +
  labs(title = "Distribution of Avg_temp Coefficients",
       x = "Avg_temp Coefficient",
       y = "Frequency") +
  theme_minimal()
```

#### 3.2.2 Just for one `genus` (Acer)

Just for one genus (Acer), the distribution of $\beta_{\text{Temp}_{\text{avg}}}$ is concentrated at -1.65, which means the warmer the preseason temperature, the earlier the spring phenology, considering the spatial autocorrelation of phenology in the model (@fig-ny_acer_tavg_SOS_2).

```{r}
#| label: ny_acer_tavg_SOS
#| include: true
#| fig-height: 10
#| fig-cap: 
#|   - "Trace plot of correlation coefficients"
#|   - "Trace plot of hyperparameters"
#| warning: false

tavg_allyear_var <- readRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_var.rds")
tavg_SOS <- tavg_allyear_var %>% filter(direction == "up" & thres == 0.5 & genus == "Acer") %>%
  na.omit()
coordinates(tavg_SOS) <- ~ lon + lat

set.seed(2025)
coords <- coordinates(tavg_SOS)
duplicated_flags <- duplicated(coords) | duplicated(coords, fromLast = TRUE)
jitter_matrix <- matrix(0, nrow = nrow(coords), ncol = 2)
jitter_matrix[duplicated_flags, ] <- matrix(rnorm(sum(duplicated_flags) * 2, mean = 0, sd = 1e-6),  ncol = 2)
coords_jittered <- coords + jitter_matrix

tavg_SOS_df <- as.data.frame(tavg_SOS)
tavg_SOS_df$lon <- coords_jittered[, 1]
tavg_SOS_df$lat <- coords_jittered[, 2]

num_predictors <- 4
D <- as.matrix(dist(coords_jittered))
n.samples <- 4000
starting <- list("phi" = 25, "sigma.sq" = 40, "tau.sq" = 100)
tuning <- list("phi" = 0.1, "sigma.sq" = 0.1, "tau.sq" = 0.1)
priors <- list(
  "beta.Norm" = list(mean = rep(0, num_predictors), var = diag(1000, num_predictors)),
  "phi.Unif" = c(5 / 1, 5 / 0.1),
  "sigma.sq.IG" = c(3, 80),
  "tau.sq.IG" = c(3, 200)
)

# model2 <- spLM(formula, data=tavg_SOS_df, coords=coords_jittered,
#               starting=starting, tuning=tuning, priors=priors,knots = c(20, 20, 0),
#               cov.model="exponential", verbose=TRUE, n.samples=n.samples, n.report=100)
# save(model2, file = "result/urban/ny_acer_tavg_SOS.RData")
load("~/phenology-urban/data/proc/urban/ny_acer_tavg_SOS.RData")

burn.in <- 0.5* n.samples
##recover beta and spatial random effects
# m.2 <- spRecover(model2, start=burn.in, verbose=TRUE)
# save(m.2, file = "result/urban/ny_acer_tavg_SOS_re.RData")
load("~/phenology-urban/data/proc/urban/ny_acer_tavg_SOS_re.RData")

plot(model2$p.beta.samples)
plot(model2$p.theta.samples)
```

```{r}
#| label: fig-ny_acer_tavg_SOS_2
#| include: true
#| fig-cap: 
#|   - "Distribution of (SOS ~ AvgTemp) coefficent"
#| warning: false

beta_samples <- as.matrix(m.2$p.beta.recover.samples)
temp_coefficients <- beta_samples[, "AvgTemp_mean"]
mean_ndvi_coef <- mean(temp_coefficients)
lower_ci <- quantile(temp_coefficients, 0.025)
upper_ci <- quantile(temp_coefficients, 0.975)

ndvi_coef_df <- data.frame(
  Coefficient = temp_coefficients,
  Type = "Avg_temp"
)
ggplot(ndvi_coef_df, aes(x = Coefficient)) +
  geom_histogram(binwidth = 0.01, fill = "blue", alpha = 0.7) +
  geom_vline(xintercept = mean_ndvi_coef, color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = mean_ndvi_coef, y = 35, label = paste0("Mean: ", round(mean_ndvi_coef, 2)), 
           color = "red", vjust = -1.5, hjust = 0.5) +
  geom_vline(xintercept = lower_ci, color = "green", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = upper_ci, color = "green", linetype = "dashed", linewidth = 1) +
  labs(title = "Distribution of Avg_temp Coefficients",
       x = "Avg_temp Coefficient",
       y = "Frequency") +
  theme_minimal()
```

<!-- #### 3.2.3 Treat `genus` as fixed effect -->

<!-- ```{r} -->

<!-- #| label: ny_fixgenus_tavg_SOS -->

<!-- #| eval: false -->

<!-- #| include: false -->

<!-- #| fig-cap:  -->

<!-- #|   - "Trace plot of hyperparameters" -->

<!-- #|   - "Distribution of (SOS ~ AvgTemp) coefficent" -->

<!-- #| warning: false -->

<!-- tavg_allyear_var <- readRDS("~/phenology-urban/data/proc/urban/NY/tavg_allyear_var.rds") -->

<!-- tavg_SOS <- tavg_allyear_var %>% filter(direction == "up" & thres == 0.5) %>% -->

<!--   na.omit() -->

<!-- coordinates(tavg_SOS) <- ~ lon + lat -->

<!-- coords <- coordinates(tavg_SOS) -->

<!-- duplicated_flags <- duplicated(coords) | duplicated(coords, fromLast = TRUE) -->

<!-- jitter_matrix <- matrix(0, nrow = nrow(coords), ncol = 2) -->

<!-- jitter_matrix[duplicated_flags, ] <- matrix(rnorm(sum(duplicated_flags) * 2, mean = 0, sd = 1e-6),  ncol = 2) -->

<!-- coords_jittered <- coords + jitter_matrix -->

<!-- tavg_SOS_df <- as.data.frame(tavg_SOS) %>% -->

<!--   select(genus, lon, lat,  doy,AvgTemp_mean,Sum_mm_sum, srad_mean) -->

<!-- tavg_SOS_df$lon <- coords_jittered[, 1] -->

<!-- tavg_SOS_df$lat <- coords_jittered[, 2] -->

<!-- genus_dummies <- model.matrix(~ genus - 1, tavg_SOS_df) -->

<!-- tavg_SOS_dummies <- model.matrix(~ lon + lat + doy + AvgTemp_mean + Sum_mm_sum + srad_mean, tavg_SOS_df) %>% -->

<!--   as.data.frame() %>% -->

<!--   bind_cols(as.data.frame(genus_dummies)) %>% -->

<!--   dplyr::select(-`(Intercept)`) -->

<!-- formula <- as.formula(paste("doy ~ ", paste(names(tavg_SOS_dummies)[!(names(tavg_SOS_dummies) %in% c("doy", "lon", "lat"))], collapse = " + "))) -->

<!-- num_predictors <- ncol(tavg_SOS_dummies) - 3+1 -->

<!-- D <- as.matrix(dist(coords_jittered)) -->

<!-- n.samples <- 3000 -->

<!-- starting <- list("phi" = 3 / 0.5, "sigma.sq" = 1, "tau.sq" = 0.1) -->

<!-- tuning <- list("phi" = 0.1, "sigma.sq" = 0.1, "tau.sq" = 0.1) -->

<!-- priors <- list( -->

<!--   "beta.Norm" = list(mean = rep(0, num_predictors), var = diag(1000, num_predictors)), -->

<!--   "phi.Unif" = c(3 / 1, 3 / 0.1), -->

<!--   "sigma.sq.IG" = c(2, 1), -->

<!--   "tau.sq.IG" = c(2, 1) -->

<!-- ) -->

<!-- model3 <- spLM(formula, data=tavg_SOS_dummies, coords=coords_jittered, -->

<!--               starting=starting, tuning=tuning, priors=priors,knots = c(20, 20, 0), -->

<!--               cov.model="exponential", verbose=TRUE, n.samples=n.samples, n.report=100) -->

<!-- save(model3, file = "result/urban/ny_fixedgenus_tavg_SOS.RData") -->

<!-- load("result/urban/ny_fixedgenus_tavg_SOS.RData") -->

<!-- burn.in <- 0.5* n.samples -->

<!-- #recover beta and spatial random effects -->

<!-- m.3 <- spRecover(model3, start=burn.in, verbose=TRUE) -->

<!-- save(m.3, file = "result/urban/ny_fixedgenus_tavg_SOS_re.RData") -->

<!-- load("result/urban/ny_fixedgenus_tavg_SOS_re.RData") -->

<!-- plot(model3$p.beta.samples) -->

<!-- plot(model3$p.theta.samples) -->

<!-- beta_samples <- as.matrix(m.3$p.beta.recover.samples) -->

<!-- temp_coefficients <- beta_samples[, "AvgTemp_mean"] -->

<!-- mean_ndvi_coef <- mean(temp_coefficients) -->

<!-- lower_ci <- quantile(temp_coefficients, 0.025) -->

<!-- upper_ci <- quantile(temp_coefficients, 0.975) -->

<!-- ndvi_coef_df <- data.frame( -->

<!--   Coefficient = temp_coefficients, -->

<!--   Type = "Avg_temp" -->

<!-- ) -->

<!-- ggplot(ndvi_coef_df, aes(x = Coefficient)) + -->

<!--   geom_histogram(binwidth = 0.01, fill = "blue", alpha = 0.7) + -->

<!--   geom_vline(xintercept = mean_ndvi_coef, color = "red", linetype = "dashed", linewidth = 1) + -->

<!--   geom_vline(xintercept = lower_ci, color = "green", linetype = "dashed", linewidth = 1) + -->

<!--   geom_vline(xintercept = upper_ci, color = "green", linetype = "dashed", linewidth = 1) + -->

<!--   labs(title = "Distribution of Avg_temp Coefficients", -->

<!--        x = "Avg_temp Coefficient", -->

<!--        y = "Frequency") + -->

<!--   theme_minimal() -->

<!-- ``` -->

<!-- ```{r} -->

<!-- create_scatter_plot <- function(data, x_var, y_var, title) { -->

<!--   # Fit the linear model -->

<!--   formula <- as.formula(paste(y_var, "~", x_var)) -->

<!--   lm_model <- lm(formula, data = data) -->

<!--   # Extract slope and p-value -->

<!--   slope <- coef(lm_model)[2] -->

<!--   p_value <- summary(lm_model)$coefficients[2, 4] -->

<!--   # Create scatter plot -->

<!--   scatter_plot <- data %>% -->

<!--     ggplot(aes(x = .data[[x_var]], y = .data[[y_var]])) + -->

<!--     geom_point() + -->

<!--     geom_smooth(method = "lm", se = TRUE) + -->

<!--     labs( -->

<!--       x = x_var, -->

<!--       y = y_var, -->

<!--       title = paste(title) -->

<!--     ) + -->

<!--     annotate( -->

<!--       "text", -->

<!--       x = min(data[[x_var]], na.rm = TRUE), -->

<!--       y = max(data[[y_var]], na.rm = TRUE), -->

<!--       label = paste0( -->

<!--         "Slope: ", round(slope, 2),  -->

<!--         "\nP-value: ", signif(p_value, 3) -->

<!--       ), -->

<!--       hjust = 0, -->

<!--       vjust = 1, -->

<!--       color = "red" -->

<!--     ) + -->

<!--     theme_classic() -->

<!--   return(scatter_plot) -->

<!-- } -->

<!-- create_scatter_plot( -->

<!--   data = seasonal_temp_doy,  -->

<!--   x_var = "Sum_Sum_mm_winter",  -->

<!--   y_var = "doy", -->

<!--   title = "Relationship between seasonal precipitation and spring phenology" -->

<!-- ) -->

<!-- model <- lmer(doy ~ Avg_AvgTemp_winter  + Sum_Sum_mm_winter  + -->

<!--                 (1 | genus),  -->

<!--               data = seasonal_temp_doy) -->

<!-- fixed_effects <- tidy(model, effects = "fixed") -->

<!-- fixed_effects_table <- fixed_effects %>% -->

<!--   select(term, estimate, std.error, statistic) %>% -->

<!--   mutate( -->

<!--     estimate = round(estimate, 3), -->

<!--     std.error = round(std.error, 3), -->

<!--     p.value = signif(2 * (1 - pnorm(abs(statistic))), 3) -->

<!--   ) -->

<!-- kable(fixed_effects_table, format = "markdown", col.names = c("Term", "Estimate", "Std. Error", "t value", "P-Value")) -->

<!-- ``` -->

## 4 Conclusion and next step

Within the city, the relationship between phenology and temperature is still significant.

-   The warmer the preseason temperature, the earlier the spring phenology, considering the spatial autocorrelation of phenology in the model
-   The precipitation has no significant impact.

Next steps:

-   Key highlights (coordinate them with Juwon):
    -   Within-city variation, fall phenology, phenology pace, different taxa
-   Preseason Optimization: At the year-, site-, and taxa-level. Individual-level pre-period might have some built-in relationship.
-   Pace: As for the algorithm, more uncertainty around 0% and 100%. Use thresholds within the period (e.g., 10–90% or 20–80%) to represent pace.
-   Spatial regression: Try spBayes to address spatial autocorrelation.
-   Future steps:
    -   Test sensitivity by changing buffer size.
    -   Add more taxa (data in DataDen and download latest PS images)
